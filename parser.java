
//----------------------------------------------------
// The following code was generated by CUP v0.10g
// Wed Apr 10 00:14:59 BST 2019
//----------------------------------------------------

import java_cup.runtime.*;

public class parser extends java_cup.runtime.lr_parser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {3, 10},     {1, 2},     {1, 1},     {2, 6}, 
        {2, 8},     {2, 4},     {2, 5},     {2, 5},     {2, 2}, 
        {4, 1},     {4, 3},     {5, 1},     {5, 1},     {5, 3}, 
        {5, 3},     {5, 3},     {5, 3},     {5, 3},     {5, 3}, 
        {5, 3},     {5, 3},     {5, 3},     {5, 3}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{26,3,-1,0},
    /*1*/{0,67,-1,0},
    /*2*/{4,4,-1,0},
    /*3*/{10,5,-1,0},
    /*4*/{4,6,-1,0},
    /*5*/{2,8,6,12,12,13,24,9,28,7,-1,0},
    /*6*/{23,64,-1,0},
    /*7*/{2,8,6,12,12,13,24,9,28,7,-1,0},
    /*8*/{21,53,-1,0},
    /*9*/{11,48,-1,0},
    /*10*/{2,8,3,-4,6,12,8,-4,9,-4,11,-4,12,13,24,9,27,-4,28,7,-1,0},
    /*11*/{21,16,28,15,29,18,-1,0},
    /*12*/{4,14,-1,0},
    /*13*/{2,-10,3,-10,6,-10,8,-10,9,-10,11,-10,12,-10,24,-10,27,-10,28,-10,-1,0},
    /*14*/{4,-14,5,-14,7,-14,13,-14,14,-14,15,-14,16,-14,17,-14,18,-14,19,-14,20,-14,22,-14,25,-14,-1,0},
    /*15*/{21,16,28,15,29,18,-1,0},
    /*16*/{5,25,7,23,13,19,14,27,15,20,16,26,17,28,18,21,19,22,20,24,-1,0},
    /*17*/{4,-13,5,-13,7,-13,13,-13,14,-13,15,-13,16,-13,17,-13,18,-13,19,-13,20,-13,22,-13,25,-13,-1,0},
    /*18*/{21,16,28,15,29,18,-1,0},
    /*19*/{21,16,28,15,29,18,-1,0},
    /*20*/{21,16,28,15,29,18,-1,0},
    /*21*/{21,16,28,15,29,18,-1,0},
    /*22*/{2,8,6,12,12,13,24,9,28,7,-1,0},
    /*23*/{21,16,28,15,29,18,-1,0},
    /*24*/{21,16,28,15,29,18,-1,0},
    /*25*/{21,16,28,15,29,18,-1,0},
    /*26*/{21,16,28,15,29,18,-1,0},
    /*27*/{21,16,28,15,29,18,-1,0},
    /*28*/{4,-20,5,-20,7,-20,13,-20,14,-20,15,-20,16,-20,17,-20,18,-20,19,-20,20,-20,22,-20,25,-20,-1,0},
    /*29*/{4,-17,5,-17,7,-17,13,-17,14,-17,15,-17,16,26,17,28,18,21,19,22,20,24,22,-17,25,-17,-1,0},
    /*30*/{4,-19,5,-19,7,-19,13,-19,14,-19,15,-19,16,-19,17,-19,18,-19,19,-19,20,-19,22,-19,25,-19,-1,0},
    /*31*/{4,-15,5,-15,7,-15,13,-15,14,27,15,20,16,26,17,28,18,21,19,22,20,24,22,-15,25,-15,-1,0},
    /*32*/{4,-23,5,-23,7,-23,13,-23,14,-23,15,-23,16,-23,17,-23,18,-23,19,-23,20,-23,22,-23,25,-23,-1,0},
    /*33*/{8,35,9,36,-1,0},
    /*34*/{2,8,6,12,12,13,24,9,28,7,-1,0},
    /*35*/{4,37,-1,0},
    /*36*/{2,-5,3,-5,6,-5,8,-5,9,-5,11,-5,12,-5,24,-5,27,-5,28,-5,-1,0},
    /*37*/{9,39,-1,0},
    /*38*/{4,40,-1,0},
    /*39*/{2,-6,3,-6,6,-6,8,-6,9,-6,11,-6,12,-6,24,-6,27,-6,28,-6,-1,0},
    /*40*/{4,-22,5,-22,7,-22,13,-22,14,-22,15,-22,16,-22,17,-22,18,-22,19,-22,20,-22,22,-22,25,-22,-1,0},
    /*41*/{4,-21,5,-21,7,-21,13,-21,14,-21,15,-21,16,-21,17,-21,18,-21,19,-21,20,-21,22,-21,25,-21,-1,0},
    /*42*/{4,-18,5,-18,7,-18,13,-18,14,-18,15,-18,16,26,17,28,18,21,19,22,20,24,22,-18,25,-18,-1,0},
    /*43*/{4,-16,5,-16,7,-16,13,-16,14,27,15,20,16,26,17,28,18,21,19,22,20,24,22,-16,25,-16,-1,0},
    /*44*/{5,25,13,19,14,27,15,20,16,26,17,28,18,21,19,22,20,24,22,46,-1,0},
    /*45*/{4,-24,5,-24,7,-24,13,-24,14,-24,15,-24,16,-24,17,-24,18,-24,19,-24,20,-24,22,-24,25,-24,-1,0},
    /*46*/{3,-3,8,-3,9,-3,11,-3,27,-3,-1,0},
    /*47*/{4,49,-1,0},
    /*48*/{2,8,6,12,12,13,24,9,28,7,-1,0},
    /*49*/{27,51,-1,0},
    /*50*/{4,52,-1,0},
    /*51*/{0,-2,-1,0},
    /*52*/{21,16,28,15,29,18,-1,0},
    /*53*/{22,58,-1,0},
    /*54*/{5,25,13,19,14,27,15,20,16,26,17,28,18,21,19,22,20,24,22,-11,25,56,-1,0},
    /*55*/{21,16,28,15,29,18,-1,0},
    /*56*/{22,-12,-1,0},
    /*57*/{4,59,-1,0},
    /*58*/{2,-9,3,-9,6,-9,8,-9,9,-9,11,-9,12,-9,24,-9,27,-9,28,-9,-1,0},
    /*59*/{3,61,-1,0},
    /*60*/{21,16,28,15,29,18,-1,0},
    /*61*/{4,63,5,25,13,19,14,27,15,20,16,26,17,28,18,21,19,22,20,24,-1,0},
    /*62*/{2,-8,3,-8,6,-8,8,-8,9,-8,11,-8,12,-8,24,-8,27,-8,28,-8,-1,0},
    /*63*/{21,16,28,15,29,18,-1,0},
    /*64*/{4,66,5,25,13,19,14,27,15,20,16,26,17,28,18,21,19,22,20,24,-1,0},
    /*65*/{2,-7,3,-7,6,-7,8,-7,9,-7,11,-7,12,-7,24,-7,27,-7,28,-7,-1,0},
    /*66*/{0,-1,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{3,1,-1,-1},
    /*1*/{-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{1,9,2,10,-1,-1},
    /*6*/{-1,-1},
    /*7*/{1,59,2,10,-1,-1},
    /*8*/{-1,-1},
    /*9*/{-1,-1},
    /*10*/{1,46,2,10,-1,-1},
    /*11*/{5,16,-1,-1},
    /*12*/{-1,-1},
    /*13*/{-1,-1},
    /*14*/{-1,-1},
    /*15*/{5,44,-1,-1},
    /*16*/{-1,-1},
    /*17*/{-1,-1},
    /*18*/{5,43,-1,-1},
    /*19*/{5,42,-1,-1},
    /*20*/{5,41,-1,-1},
    /*21*/{5,40,-1,-1},
    /*22*/{1,33,2,10,-1,-1},
    /*23*/{5,32,-1,-1},
    /*24*/{5,31,-1,-1},
    /*25*/{5,30,-1,-1},
    /*26*/{5,29,-1,-1},
    /*27*/{5,28,-1,-1},
    /*28*/{-1,-1},
    /*29*/{-1,-1},
    /*30*/{-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{1,37,2,10,-1,-1},
    /*35*/{-1,-1},
    /*36*/{-1,-1},
    /*37*/{-1,-1},
    /*38*/{-1,-1},
    /*39*/{-1,-1},
    /*40*/{-1,-1},
    /*41*/{-1,-1},
    /*42*/{-1,-1},
    /*43*/{-1,-1},
    /*44*/{-1,-1},
    /*45*/{-1,-1},
    /*46*/{-1,-1},
    /*47*/{-1,-1},
    /*48*/{1,49,2,10,-1,-1},
    /*49*/{-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{4,53,5,54,-1,-1},
    /*53*/{-1,-1},
    /*54*/{-1,-1},
    /*55*/{4,56,5,54,-1,-1},
    /*56*/{-1,-1},
    /*57*/{-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{5,61,-1,-1},
    /*61*/{-1,-1},
    /*62*/{-1,-1},
    /*63*/{5,64,-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$parser$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 0;}

  /** EOF Symbol index */
  public int EOF_sym() {return 0;}

  /** error Symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 scanner.init();              
    }

  /** scan to get the next Symbol */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return scanner.next_token(); 
    }


  public static void main(String args[]) throws java.io.IOException {
   parser parser_obj = new parser();
   Symbol parse_tree = null;
   try { parse_tree = parser_obj.parse(); }
   catch (Throwable e) {        e.printStackTrace();
        throw new Error(e.toString());
 };
}
        
}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {

 


/**** interpStm ****/

/* This method a takes member of the statement class s
and a current table t and returns the table updated by s
(although some statements such as 'print' may not update the table).
It branches depending on what is the outermost constructor of s:
-If s is a print, it calls the method printList
with the list of expressions as first arg, and the current
table as second.  Print does NOT change the table.
-If s is an assignment, it returns the table value of the method
`update' when called with the current table, the assignment's
LHS, and the value of the RHS calcuated in the current table 
(note evaluating the RHS itself can't change the current table).
-If s is one statement s1 following by another s2, s2 is interpreted
in the table got by interpreting s1 in the current table t.
otherwise we have an error.  
-If s is a Do-While (i.e. a Repeat statement), it returns the table after the
repeat's statements have been executed one or more times */

 Table interpStm(Stm s, Stm r, Table t) {  
   if (s instanceof PrintStm)  
     {  printList(s.getExps(), t);
        return t;
     }
   else if (s instanceof AssignStm)
        return update(t,s.getLHS(),interpExp(s.getRHS(), t));
   else if (s instanceof CompoundStm)
        return interpStm(s.get2(), r, interpStm(s.get1(), r, t));
   else if (s instanceof RepeatStm)
/* first change table to simulate execution of stms inside repeat.. */
      {  Table table_temp = interpStm(s.getRepStm(), r, t);   
/* find value of e in new table.. */
         int   int_temp = interpExp(s.getRepExp(),table_temp);
/* call statements again if expression is non-zero */
         if (int_temp == 0) return table_temp; else
         return interpStm(s,r, table_temp); }
   else if (s instanceof IfthenStm)
	{ int temp = interpExp(s.getIfthenExp(),t);
	   if(temp == 0) return t; else
	   return interpStm(s.getIfthenStm(),r,t);}
   else if (s instanceof IfthenElseStm)
	{ int temp = interpExp(s.getIfthenExp(),t);
	   if(temp == 0) return interpStm(s.getElseStm(),r,t); else
	   return interpStm(s.getIfthenStm(),r,t);}
   else if (s instanceof CallStm)
	{
	    return interpStm(r,r,t);
	}
   else 
        System.out.println("error in stm");
        return t;
  }

/**** interpExp ****/

/* interpExp takes an expression e and a table t and returns the
value of e within the context of t.
-If e is a number return that number.
-If e is an identifier, return the looked up value of id in table t.
-If e is a binary operator expression:
  get the value of the left expression and
  get the value of the right expression 
 return the value of the right and left expressions
 operated on by whatever binary operator we have.
otherwise we have an error */

 int interpExp(Exp e, Table t) {
  if (e instanceof NumExp) 
       return e.getInt();
  else if (e instanceof IdExp) 
       return lookup(t,e.geteid());
  else if (e instanceof OpExp)
         {
            int   i_temp1 = interpExp(e.getleft(),t);
            int   i_temp2 = interpExp(e.getright(),t);
          if (e.getoper() == 1) 
           return (i_temp1+i_temp2); 
          else if (e.getoper() == 2) 
           return (i_temp1 - i_temp2); 
          else if (e.getoper() == 3) 
           return (i_temp1 * i_temp2); 
          else if (e.getoper() == 4) 
           return (i_temp1 / i_temp2); 
          else if (e.getoper() == 5 && i_temp1 > i_temp2) 
           return (1); 
          else if (e.getoper() == 5 && i_temp1 == i_temp2) 
           return (0); 
          else if (e.getoper() == 5 && i_temp1 < i_temp2) 
           return (0);
	  else if (e.getoper() == 6 && i_temp1 > i_temp2)
	   return (0);
	  else if (e.getoper() == 6 && i_temp1 == i_temp2)
	   return (0);
	  else if (e.getoper() == 6 && i_temp1 < i_temp2)
	   return (1);
	  else if (e.getoper() == 7 && i_temp1 > i_temp2)
           return (1);
          else if (e.getoper() == 7 && i_temp1 == i_temp2)
           return (1);
          else if (e.getoper() == 7 && i_temp1 < i_temp2)
           return (0);
	  else if (e.getoper() == 8 && i_temp1 > i_temp2)
           return (0);
          else if (e.getoper() == 8 && i_temp1 == i_temp2)
           return (1);
          else if (e.getoper() == 8 && i_temp1 < i_temp2)
           return (1);
          else if (e.getoper() == 9 && i_temp1 > i_temp2)
           return (0);
          else if (e.getoper() == 9 && i_temp1 == i_temp2)
           return (1);
          else if (e.getoper() == 9 && i_temp1 < i_temp2)
           return (0);

          else throw new Error("error in Exp");
        }
  else throw new Error("Exp not recognised");
  }

/**** update ****/

/* constructor for a Table that implements the table
-- it simply adds the pair str, i to the old table t,
where str is the identifier and i the int value. */


 Table update(Table t,String str, int i) {
  return (new Table(str, i, t));}

/* selector for a Table - returns the integer value
associated with key once its found */


 int lookup(Table t, String key) {
  if (t.getid().equals(key)) return t.getint(); 
           else return lookup(t.gettail(),key);
  }


/* This class represents the Store of the program */

class Table {
  String id; int value; Table tail;
  Table(String i, int v, Table t)  {id =i; value=v; tail=t;}

  public String getid() {return id;}
  public int getint() {return value;}
  public Table gettail() {return tail;}
}


void  printList(ExpList expL, Table t) {
  if (expL instanceof PairExpList) 
     { 
       System.out.print(interpExp(expL.gethead(),t));
       System.out.print(" ");
       printList(  expL.gettail(), t );
      }
   else 
      /* exp is LastExpList */
              System.out.println(interpExp(expL.gethead(),t));
  }

/* The following classes represent the syntax classes of
   the language. They have constructirs and accesssors */

abstract class Stm { 
   protected ExpList getExps() {return null;}; 
   protected Stm get1() {return null;};
   protected Stm get2() {return null;};
   protected Exp getRHS() {return null;};
   protected String getLHS() {return null;};
   protected Stm getRepStm() {return null;};
   protected Exp getRepExp() {return null;};
   protected Stm getIfthenStm() {return null;};
   protected Exp getIfthenExp() {return null;};
   protected Stm getElseStm() {return null;};
}

class CompoundStm extends Stm {
   Stm stm1, stm2;
   CompoundStm(Stm s1, Stm s2) {stm1=s1; stm2=s2;}

   public Stm get1() {return stm1;}
   public Stm get2() {return stm2;}
}

class AssignStm extends Stm {
   String id; Exp exp;
   AssignStm(String i, Exp e) {id=i; exp=e;}
   
   public Exp getRHS() {return exp;}
   public String getLHS() {return id;}
}

class PrintStm extends Stm {
   ExpList exps;
   PrintStm(ExpList e) {exps=e;}

   public ExpList getExps() {return exps;}
}
class RepeatStm extends Stm {
   Stm s; Exp exp;
   RepeatStm(Stm a, Exp e) {s=a; exp=e;}

   public Stm getRepStm() {return s;}
   public Exp getRepExp() {return exp;} 
}

class IfthenStm extends Stm {
   Stm s; Exp exp;
   IfthenStm(Stm a, Exp e) {s=a; exp=e;}
   public Stm getIfthenStm() {return s;}
   public Exp getIfthenExp() {return exp;}
}

class IfthenElseStm extends Stm{
   Stm s1; Exp exp; Stm s2;
   IfthenElseStm(Stm a, Stm b, Exp e) {s1=a; s2=b; exp = e;}
   public Stm getIfthenStm() {return s1;}
   public Exp getIfthenExp() {return exp;}
   public Stm getElseStm() {return s2;}
}

class CallStm extends Stm{
  CallStm(){}
}


abstract class Exp {
   protected int getInt() { return 0;};
   protected String geteid() {return null;};
   protected Stm getStm()   {return null;}; 
   protected Exp getExp() {return null;};
   protected int getoper() {return 0;}
   protected Exp getleft() {return null;}
   protected Exp getright() {return null;}
}

class IdExp extends Exp {
   String id;
   IdExp(String i) {id=i;}
   public String geteid() {return id;}  
}

class NumExp extends Exp {
   int num;
   NumExp(int n) {num=n;}
   public int getInt() {return num;}
}

class OpExp extends Exp {
   Exp left, right; int oper;
   final static int Plus=1,Minus=2,Times=3,Div=4,Gthan=5,Lthan=6,GthanEqual=7,LthanEqual=8,Equal=9;
   OpExp(Exp l, int o, Exp r) {left=l; oper=o; right=r;}
   public int getoper() {return oper;}
   public Exp getleft() {return left;}
   public Exp getright() {return right;}
}

abstract class ExpList { 
   abstract Exp gethead() ;
   protected ExpList gettail() {return null;};
}

class PairExpList extends ExpList {
   Exp head; ExpList tail;
   PairExpList(Exp h, ExpList t) {head=h; tail=t;}

   public ExpList gettail() {return tail;}
   public Exp gethead() {return head;}
}

class LastExpList extends ExpList {
   Exp head; 
   LastExpList(Exp h) {head=h;}

   public Exp gethead() {return head;}
}
            

  /** Constructor */
  CUP$parser$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // exp ::= LPAREN exp RPAREN 
            {
              Exp RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e; 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // exp ::= exp EQUAL exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Equal,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // exp ::= exp LTE exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.LthanEqual,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // exp ::= exp GTE exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.GthanEqual,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // exp ::= exp LT exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Lthan,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // exp ::= exp GT exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Gthan,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // exp ::= exp DIVIDE exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Div,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // exp ::= exp TIMES exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Times,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // exp ::= exp MINUS exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Minus,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // exp ::= exp PLUS exp 
            {
              Exp RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new OpExp(e1,OpExp.Plus,e2); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // exp ::= ID 
            {
              Exp RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		RESULT = new IdExp(id);
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // exp ::= INT 
            {
              Exp RESULT = null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new NumExp(n.intValue()); 
              CUP$parser$result = new java_cup.runtime.Symbol(5/*exp*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // exps ::= exp COMMA exps 
            {
              ExpList RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int esleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int esright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		ExpList es = (ExpList)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new PairExpList(e,es); 
              CUP$parser$result = new java_cup.runtime.Symbol(4/*exps*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // exps ::= exp 
            {
              ExpList RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new LastExpList(e); 
              CUP$parser$result = new java_cup.runtime.Symbol(4/*exps*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // single_stm ::= CALL SEMI 
            {
              Stm RESULT = null;
		 RESULT = new CallStm(); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // single_stm ::= PRINT LPAREN exps RPAREN SEMI 
            {
              Stm RESULT = null;
		int esleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int esright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpList es = (ExpList)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new PrintStm(es); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // single_stm ::= DO stm WHILE exp SEMI 
            {
              Stm RESULT = null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new RepeatStm(s1,e); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // single_stm ::= ID ASSIGNS exp SEMI 
            {
              Stm RESULT = null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new AssignStm(id,e); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // single_stm ::= IF exp THEN stm ELSE stm ENDIF SEMI 
            {
              Stm RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s2 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new IfthenElseStm(s1,s2,e); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // single_stm ::= IF exp THEN stm ENDIF SEMI 
            {
              Stm RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new IfthenStm(s,e); 
              CUP$parser$result = new java_cup.runtime.Symbol(2/*single_stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // stm ::= single_stm 
            {
              Stm RESULT = null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = s1; 
              CUP$parser$result = new java_cup.runtime.Symbol(1/*stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // stm ::= single_stm stm 
            {
              Stm RESULT = null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Stm s2 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		 RESULT = new CompoundStm(s1,s2); 
              CUP$parser$result = new java_cup.runtime.Symbol(1/*stm*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // prog ::= START SEMI FUNCTION SEMI stm END SEMI stm FINISH SEMI 
            {
              Table RESULT = null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Stm r = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = interpStm(s, r, new Table("",0,null)); 
              CUP$parser$result = new java_cup.runtime.Symbol(3/*prog*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= prog EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Table start_val = (Table)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

